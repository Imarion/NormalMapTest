// based on Tom Dalling tuto: http://www.tomdalling.com/blog/modern-opengl/06-diffuse-point-lighting/

#version 420

layout (location = 0) in vec3 vert;
layout (location = 1) in vec3 vertNormal;
layout (location = 2) in vec2 vertTexCoord;
layout (location = 3) in vec3 Tangent;

struct BaseLight
{
    vec3  Color;
    float AmbientIntensity;
    float DiffuseIntensity;
};

struct DirectionalLight
{
    BaseLight Base;
    vec3      Direction; // TO DO: change to position
};

uniform DirectionalLight gDirectionalLight;

uniform mat4 camera; // matrix with perspective+look at
uniform mat4 model;

out vec3 fragVert;
out vec2 fragTexCoord;
out vec3 fragNormal;
out vec3 fragTangent;

void main()
{

    // Pass some variables to the fragment shader
    fragVert     = vert;
    fragTexCoord = vertTexCoord;
    fragNormal   = vertNormal;
    fragTangent  = Tangent;

    // Apply all matrix transformations to vert
    gl_Position = camera * model * vec4(vert, 1);

/*
    mat3 m_3x3_inv_transp = transpose(inverse(mat3(gWorld)));

    WorldPos0   = (gWorld * vec4(Position, 1.0)).xyz;
    TexCoord0   = TexCoord;

    //TBN[0] = normalize(vec3(gWorld * vec4(Tangent, 0.0)));
    TBN[0] = normalize(m_3x3_inv_transp * Tangent);
    TBN[2] = normalize(m_3x3_inv_transp * Normal);
    TBN[1] = normalize(cross(TBN[2], TBN[0]));
*/

/*
    TexCoord0   = TexCoord;
    mat3 NormalMatrix = transpose(inverse(mat3(gWorld)));

    // Building the matrix Eye Space -> Tangent Space
    vec3 n = normalize (NormalMatrix * Normal);
    vec3 t = normalize (NormalMatrix * Tangent);
    vec3 b = cross (n, t);

    vec3 vertexPosition = vec3(gWorld * vec4 (Position, 1.0));
    vec3 lightDir = normalize(gDirectionalLight.Direction - vertexPosition); // ! direction= position actually

    // transform light and half angle vectors by tangent basis
    vec3 v;
    v.x = dot (lightDir, t);
    v.y = dot (lightDir, b);
    v.z = dot (lightDir, n);
    lightVec = normalize (v);

    v.x = dot (vertexPosition, t);
    v.y = dot (vertexPosition, b);
    v.z = dot (vertexPosition, n);
    eyeVec = normalize (v);


    vertexPosition = normalize(vertexPosition);

    // Normalize the halfVector to pass it to the fragment shader

    // No need to divide by two, the result is normalized anyway.
    // vec3 halfVector = normalize((vertexPosition + lightDir) / 2.0);
    vec3 halfVector = normalize(vertexPosition + lightDir);
    v.x = dot (halfVector, t);
    v.y = dot (halfVector, b);
    v.z = dot (halfVector, n);

    // No need to normalize, t,b,n and halfVector are normal vectors.
    //normalize (v);
    halfVec = v ;

    gl_Position = gWVP * vec4(Position, 1.0);
*/

}
                                                                                                                                          
